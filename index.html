<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Iscas de Abelhas - Rastreador de Trajeto</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Cor da barra do navegador / PWA -->
  <meta name="theme-color" content="#145a32" />

  <!-- Manifesto PWA -->
  <link rel="manifest" href="manifest.webmanifest" />

  <!-- Leaflet (mapa) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
  </script>

  <style>
    :root {
      --primary: #145a32;
      --primary-dark: #0b3d21;
      --accent: #f1c40f;
      --bg: #f4f6f7;
      --border-radius: 12px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #222;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
    }

    header h1 {
      margin: 0;
      font-size: 1.3rem;
    }

    header p {
      margin: 4px 0 0;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    main {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      flex: 1;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      padding: 10px 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.2s;
      white-space: nowrap;
    }

    button:active {
      transform: scale(0.97);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) inset;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-secondary {
      background: #e5e7e9;
      color: #333;
    }

    .btn-danger {
      background: #c0392b;
      color: white;
    }

    .btn-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-small {
      padding: 5px 10px;
      font-size: 0.8rem;
    }

    #status {
      font-size: 0.85rem;
      margin-top: 6px;
      color: #555;
    }

    label {
      font-size: 0.85rem;
      margin-right: 6px;
    }

    select {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
      max-width: 100%;
    }

    .route-header {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }

    .route-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    #map {
      width: 100%;
      height: 55vh;
      border-radius: var(--border-radius);
      overflow: hidden;
    }

    .info {
      font-size: 0.8rem;
      color: #555;
    }

    .info strong {
      color: #222;
    }

    .trap-list {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 6px;
      padding-left: 16px;
      font-size: 0.8rem;
    }

    .trap-item {
      margin-bottom: 8px;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #eaf2f8;
      color: #1b4f72;
      margin-left: 4px;
    }

    .photo-thumb {
      max-width: 100px;
      max-height: 80px;
      display: block;
      margin-top: 4px;
      border-radius: 8px;
      cursor: zoom-in;
    }

    footer {
      text-align: center;
      padding: 4px 8px;
      font-size: 0.7rem;
      color: #777;
    }

    /* Modal de foto ampliada */
    .photo-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 10px;
    }

    .photo-modal.visible {
      display: flex;
    }

    .photo-modal img {
      max-width: 100%;
      max-height: 100%;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    }

    .photo-modal-hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #eee;
      font-size: 0.8rem;
      text-align: center;
      opacity: 0.8;
    }

    @media (min-width: 768px) {
      main {
        flex-direction: row;
      }

      #map {
        height: 70vh;
      }

      .left,
      .right {
        flex: 1;
      }

      .left {
        max-width: 380px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Iscas de Abelhas ‚Äì Rastreador</h1>
    <p>Registre seus trajetos, marque pontos de isca com foto e consulte depois.</p>
  </header>

  <main>
    <section class="left">
      <div class="card">
        <div class="controls">
          <button id="btnStartStop" class="btn-primary">
            ‚ñ∂ Iniciar trajeto
          </button>

          <button id="btnMarkTrap" class="btn-secondary btn-disabled" disabled>
            üìç Marcar ponto de isca
          </button>
        </div>

        <div id="status">
          Aguardando in√≠cio do trajeto‚Ä¶
        </div>
      </div>

      <div class="card" style="margin-top: 8px;">
        <div class="route-header" style="margin-bottom: 6px;">
          <div>
            <label for="routeSelect"><strong>Trajetos salvos:</strong></label>
            <select id="routeSelect">
              <option value="">Selecione um trajeto‚Ä¶</option>
            </select>
          </div>
        </div>

        <div class="route-actions">
          <button id="btnRenameRoute" class="btn-secondary btn-small">
            ‚úèÔ∏è Renomear trajeto
          </button>
          <button id="btnDeleteRoute" class="btn-secondary btn-small">
            üóëÔ∏è Excluir trajeto
          </button>
          <button id="btnMonitorRoute" class="btn-secondary btn-small">
            üì° Monitorar iscas
          </button>
          <button id="btnNextTrap" class="btn-secondary btn-small btn-disabled" disabled>
            ‚û° Pr√≥xima isca
          </button>
        </div>

        <div class="info" id="routeInfo" style="margin-top: 8px;">
          Nenhum trajeto selecionado.
        </div>

        <div class="info" id="monitorInfo" style="margin-top: 6px;">
          Monitoramento de iscas inativo.
        </div>

        <div class="trap-list" id="trapList">
          <!-- lista de pontos de isca -->
        </div>
      </div>
    </section>

    <section class="right">
      <div class="card" style="padding: 0;">
        <div id="map"></div>
      </div>
    </section>
  </main>

  <footer>
    Webapp did√°tico ‚Äì dados salvos apenas no seu navegador (localStorage).
  </footer>

  <!-- Input de foto oculto (usado ao marcar isca) -->
  <input
    type="file"
    id="photoInput"
    accept="image/*"
    capture="environment"
    style="display: none;"
  />

  <!-- Modal para foto ampliada -->
  <div id="photoModal" class="photo-modal">
    <img id="photoModalImg" src="" alt="Foto ampliada da isca" />
    <div class="photo-modal-hint">Toque em qualquer lugar para fechar</div>
  </div>

  <script>
    /************************************************************
     * ESTADO GLOBAL
     ************************************************************/
    let map;
    let pathPolyline;
    let currentMarker;
    let trapsLayerGroup;
    let monitorLine; // linha entre posi√ß√£o atual e pr√≥xima isca

    let isTracking = false;
    let watchId = null;
    let currentRoute = null;

    // Estado do monitoramento de iscas
    const monitorState = {
      active: false,
      routeId: null,
      visited: [],
      currentTrapId: null,
      watchId: null,
      currentPosition: null,
    };

    // Armazena todos os trajetos salvos (no dispositivo)
    const STORAGE_KEY = "iscas_trajetos_v1";

    /************************************************************
     * INICIALIZA√á√ÉO
     ************************************************************/
    document.addEventListener("DOMContentLoaded", () => {
      initMap();
      bindUI();
      setupPhotoModal();
      loadRoutesFromStorage();
    });

    function initMap() {
      // Mapa inicial, centro aproximado no Brasil
      map = L.map("map").setView([-15.0, -56.0], 5);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "¬© OpenStreetMap contributors",
      }).addTo(map);

      pathPolyline = L.polyline([], { weight: 4 }).addTo(map);
      trapsLayerGroup = L.layerGroup().addTo(map);
      monitorLine = L.polyline([], { weight: 2, dashArray: "5,5" }).addTo(map);
    }

    function bindUI() {
      const btnStartStop = document.getElementById("btnStartStop");
      const btnMarkTrap = document.getElementById("btnMarkTrap");
      const routeSelect = document.getElementById("routeSelect");
      const photoInput = document.getElementById("photoInput");
      const btnRenameRoute = document.getElementById("btnRenameRoute");
      const btnDeleteRoute = document.getElementById("btnDeleteRoute");
      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");

      btnStartStop.addEventListener("click", () => {
        if (!isTracking) {
          startTracking();
        } else {
          stopTracking();
        }
      });

      btnMarkTrap.addEventListener("click", () => {
        if (!isTracking || !currentRoute) {
          alert("Inicie um trajeto antes de marcar pontos de isca.");
          return;
        }
        handleMarkTrap();
      });

      routeSelect.addEventListener("change", () => {
        const id = routeSelect.value;
        if (!id) {
          clearMapLayers();
          updateRouteInfo(null);
          updateMonitorInfo("Monitoramento de iscas inativo.");
          return;
        }
        const routes = getAllRoutes();
        const route = routes.find((r) => r.id === id);
        if (route) {
          showRouteOnMap(route);
          updateRouteInfo(route);
          renderTrapList(route);
          // se mudar de trajeto durante monitoramento, interrompe
          if (monitorState.active && monitorState.routeId !== id) {
            stopMonitoringRoute();
          }
        }
      });

      // Renomear trajeto
      btnRenameRoute.addEventListener("click", () => {
        const select = document.getElementById("routeSelect");
        const id = select.value;
        if (!id) {
          alert("Selecione um trajeto para renomear.");
          return;
        }
        // se estiver monitorando esse trajeto, para o monitoramento
        if (monitorState.active) {
          stopMonitoringRoute();
        }
        renameRoute(id);
      });

      // Excluir trajeto
      btnDeleteRoute.addEventListener("click", () => {
        const select = document.getElementById("routeSelect");
        const id = select.value;
        if (!id) {
          alert("Selecione um trajeto para excluir.");
          return;
        }
        // se estiver monitorando esse trajeto, para o monitoramento
        if (monitorState.active && monitorState.routeId === id) {
          stopMonitoringRoute();
        }
        deleteRoute(id);
      });

      // Monitorar iscas
      btnMonitorRoute.addEventListener("click", () => {
        const select = document.getElementById("routeSelect");
        const id = select.value;
        if (!id) {
          alert("Selecione um trajeto para monitorar.");
          return;
        }

        if (!monitorState.active) {
          startMonitoringRoute(id);
        } else {
          stopMonitoringRoute();
        }
      });

      // Pr√≥xima isca
      btnNextTrap.addEventListener("click", () => {
        goToNextTrap();
      });

      // Quando o usu√°rio escolhe/tira a foto, tratamos no evento change
      photoInput.addEventListener("change", handlePhotoSelected);
    }

    /************************************************************
     * FUN√á√ïES DE ARMAZENAMENTO
     ************************************************************/
    function getAllRoutes() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        return JSON.parse(raw);
      } catch (e) {
        console.error("Erro ao ler localStorage:", e);
        return [];
      }
    }

    function saveAllRoutes(routes) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(routes));
    }

    function addRoute(route) {
      const routes = getAllRoutes();
      routes.push(route);
      saveAllRoutes(routes);
    }

    function loadRoutesFromStorage() {
      const routeSelect = document.getElementById("routeSelect");
      const routes = getAllRoutes();

      // Limpa e repopula o select
      routeSelect.innerHTML = '<option value="">Selecione um trajeto‚Ä¶</option>';

      routes.forEach((r) => {
        const inicioStr =
          r.path && r.path.length > 0
            ? formatDateTime(new Date(r.path[0].timestamp))
            : formatDateTime(new Date(r.createdAt));
        const totalIscas = r.traps ? r.traps.length : 0;

        const opt = document.createElement("option");
        opt.value = r.id;
        opt.textContent = `${r.name} ‚Äì ${totalIscas} isca(s) ‚Äì ${inicioStr}`;
        routeSelect.appendChild(opt);
      });
    }

    /************************************************************
     * CONTROLE DO TRAJETO (GPS - GRAVA√á√ÉO)
     ************************************************************/
    function startTracking() {
      if (!("geolocation" in navigator)) {
        alert("Seu navegador n√£o suporta Geolocaliza√ß√£o.");
        return;
      }

      if (monitorState.active) {
        alert("Pare o monitoramento de iscas antes de iniciar um novo trajeto.");
        return;
      }

      const name = prompt("Nome para este trajeto (ex: Matas do S√≠tio A):", "");
      if (!name) {
        alert("Trajeto n√£o iniciado (nome √© obrigat√≥rio).");
        return;
      }

      isTracking = true;
      currentRoute = {
        id: "route_" + Date.now(),
        name: name,
        createdAt: new Date().toISOString(),
        path: [],
        traps: [],
      };

      pathPolyline.setLatLngs([]);
      trapsLayerGroup.clearLayers();
      monitorLine.setLatLngs([]);
      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }

      const status = document.getElementById("status");
      status.textContent = "Gravando trajeto‚Ä¶ caminhando com GPS ligado.";
      toggleTrackingButtons(true);

      // Inicia o watchPosition
      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          const point = {
            lat: latitude,
            lng: longitude,
            timestamp: new Date().toISOString(),
          };
          currentRoute.path.push(point);

          // Atualiza linha no mapa
          pathPolyline.addLatLng([latitude, longitude]);

          // Atualiza marcador de posi√ß√£o atual
          if (currentMarker) {
            currentMarker.setLatLng([latitude, longitude]);
          } else {
            currentMarker = L.marker([latitude, longitude]).addTo(map);
          }

          // Ajusta o mapa para mostrar a posi√ß√£o atual
          map.setView([latitude, longitude], 16);
        },
        (err) => {
          console.error("Erro no watchPosition:", err);
          alert("N√£o foi poss√≠vel obter sua localiza√ß√£o: " + err.message);
          stopTracking();
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 20000,
        }
      );
    }

    function stopTracking() {
      if (!isTracking) return;

      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      isTracking = false;
      toggleTrackingButtons(false);

      const status = document.getElementById("status");
      status.textContent = "Trajeto encerrado.";

      if (currentRoute && currentRoute.path.length > 0) {
        // Salva a rota atual
        addRoute(currentRoute);

        // Recarrega a lista de trajetos salvos
        loadRoutesFromStorage();

        // Seleciona automaticamente o trajeto rec√©m-salvo no <select>
        const routeSelect = document.getElementById("routeSelect");
        routeSelect.value = currentRoute.id;

        // Mostra a rota no mapa e o resumo abaixo
        showRouteOnMap(currentRoute);
        updateRouteInfo(currentRoute);
        renderTrapList(currentRoute);

        alert("Trajeto salvo com sucesso!");
      } else {
        alert("Nenhum ponto foi registrado. Trajeto n√£o ser√° salvo.");
      }

      // Limpa o objeto em mem√≥ria
      currentRoute = null;
    }

    function toggleTrackingButtons(tracking) {
      const btnStartStop = document.getElementById("btnStartStop");
      const btnMarkTrap = document.getElementById("btnMarkTrap");

      if (tracking) {
        btnStartStop.textContent = "‚ñ† Encerrar trajeto";
        btnStartStop.classList.remove("btn-primary");
        btnStartStop.classList.add("btn-danger");

        btnMarkTrap.disabled = false;
        btnMarkTrap.classList.remove("btn-disabled");
      } else {
        btnStartStop.textContent = "‚ñ∂ Iniciar trajeto";
        btnStartStop.classList.remove("btn-danger");
        btnStartStop.classList.add("btn-primary");

        btnMarkTrap.disabled = true;
        btnMarkTrap.classList.add("btn-disabled");
      }
    }

    /************************************************************
     * MARCAR PONTO DE ISCA (COM FOTO)
     ************************************************************/
    let pendingTrapPosition = null; // guarda posi√ß√£o enquanto espera foto
    function handleMarkTrap() {
      if (!currentRoute) return;

      const lastPoint = currentRoute.path[currentRoute.path.length - 1];

      const finishMark = (lat, lng) => {
        pendingTrapPosition = { lat, lng, timestamp: new Date().toISOString() };
        // Abre input de foto
        document.getElementById("photoInput").click();
      };

      if (lastPoint) {
        finishMark(lastPoint.lat, lastPoint.lng);
      } else {
        // Se ainda n√£o h√° pontos no trajeto, tenta pegar posi√ß√£o atual
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            finishMark(latitude, longitude);
          },
          (err) => {
            alert(
              "N√£o foi poss√≠vel obter a localiza√ß√£o para marcar o ponto: " +
                err.message
            );
          },
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 15000,
          }
        );
      }
    }

    function handlePhotoSelected(event) {
      const file = event.target.files[0];
      if (!pendingTrapPosition) {
        // estado inconsistente, apenas limpa input
        event.target.value = "";
        return;
      }

      const note =
        prompt("Alguma observa√ß√£o sobre esta isca? (opcional)", "") || "";

      if (!file) {
        // Usu√°rio cancelou a sele√ß√£o de foto, ainda assim podemos registrar o ponto sem foto
        registerTrap(
          pendingTrapPosition.lat,
          pendingTrapPosition.lng,
          null,
          note
        );
        pendingTrapPosition = null;
        return;
      }

      const reader = new FileReader();
      reader.onload = function (e) {
        const photoDataUrl = e.target.result;
        registerTrap(
          pendingTrapPosition.lat,
          pendingTrapPosition.lng,
          photoDataUrl,
          note
        );
        pendingTrapPosition = null;
        event.target.value = "";
      };
      reader.readAsDataURL(file);
    }

    function registerTrap(lat, lng, photoDataUrl, note) {
      if (!currentRoute) return;

      const trap = {
        id: "trap_" + Date.now(),
        lat,
        lng,
        timestamp: new Date().toISOString(),
        note,
        photo: photoDataUrl, // pode ser null
      };

      currentRoute.traps.push(trap);

      // Adiciona marcador no mapa
      const popupHtml = createTrapPopupHtml(trap);
      const marker = L.marker([lat, lng]).addTo(trapsLayerGroup);
      marker.bindPopup(popupHtml);

      alert("Ponto de isca registrado!");
    }

    function createTrapPopupHtml(trap) {
      const dt = formatDateTime(new Date(trap.timestamp));
      let html = `<div><strong>Ponto de isca</strong><br/><small>${dt}</small>`;
      if (trap.note) {
        html += `<br/><em>${escapeHtml(trap.note)}</em>`;
      }
      if (trap.photo) {
        html += `<br/><img src="${trap.photo}" alt="Foto da isca" style="max-width:120px;max-height:90px;margin-top:4px;border-radius:6px;" />`;
      }
      html += `</div>`;
      return html;
    }

    /************************************************************
     * EXIBI√á√ÉO NO MAPA / LISTA
     ************************************************************/
    function clearMapLayers() {
      pathPolyline.setLatLngs([]);
      trapsLayerGroup.clearLayers();
      monitorLine.setLatLngs([]);
      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }
    }

    function showRouteOnMap(route) {
      clearMapLayers();

      if (!route.path || route.path.length === 0) return;

      const latlngs = route.path.map((p) => [p.lat, p.lng]);
      pathPolyline.setLatLngs(latlngs);

      // Posi√ß√£o final como marcador "atual"
      const last = latlngs[latlngs.length - 1];
      currentMarker = L.marker(last).addTo(map);

      // Pontos de isca
      if (route.traps && route.traps.length > 0) {
        route.traps.forEach((trap) => {
          const marker = L.marker([trap.lat, trap.lng]).addTo(trapsLayerGroup);
          marker.bindPopup(createTrapPopupHtml(trap));
        });
      }

      // Ajusta mapa para mostrar todo o trajeto
      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds, { padding: [20, 20] });
    }

    function updateRouteInfo(route) {
      const infoDiv = document.getElementById("routeInfo");
      if (!route) {
        infoDiv.textContent = "Nenhum trajeto selecionado.";
        document.getElementById("trapList").innerHTML = "";
        return;
      }

      const totalPontos = route.path ? route.path.length : 0;
      const totalIscas = route.traps ? route.traps.length : 0;

      // In√≠cio e fim do trajeto (com base nos timestamps do path)
      let inicioStr = "-";
      let fimStr = "-";

      if (route.path && route.path.length > 0) {
        const inicio = new Date(route.path[0].timestamp);
        const fim = new Date(route.path[route.path.length - 1].timestamp);
        inicioStr = formatDateTime(inicio);
        fimStr = formatDateTime(fim);
      }

      infoDiv.innerHTML = `
        <div><strong>${escapeHtml(route.name)}</strong></div>
        <div>In√≠cio do trajeto: <strong>${inicioStr}</strong></div>
        <div>Fim do trajeto: <strong>${fimStr}</strong></div>
        <div>Pontos do caminho (GPS): <strong>${totalPontos}</strong></div>
        <div>N¬∫ de iscas marcadas: <strong>${totalIscas}</strong></div>
      `;
    }

    function renderTrapList(route) {
      const listDiv = document.getElementById("trapList");
      listDiv.innerHTML = "";
      if (!route.traps || route.traps.length === 0) {
        listDiv.textContent = "Nenhum ponto de isca registrado neste trajeto.";
        return;
      }

      route.traps.forEach((trap, idx) => {
        const dt = formatDateTime(new Date(trap.timestamp));
        const item = document.createElement("div");
        item.className = "trap-item";
        item.innerHTML = `
          <strong>Isca ${idx + 1}</strong>
          <span class="badge">${trap.lat.toFixed(5)}, ${trap.lng.toFixed(5)}</span><br/>
          <small>${dt}</small><br/>
          ${
            trap.note
              ? `<em>${escapeHtml(trap.note)}</em><br/>`
              : ""
          }
        `;
        if (trap.photo) {
          const img = document.createElement("img");
          img.src = trap.photo;
          img.alt = "Foto da isca";
          img.className = "photo-thumb";
          img.addEventListener("click", () => {
            openPhotoModal(trap.photo);
          });
          item.appendChild(img);
        }
        listDiv.appendChild(item);
      });
    }

    /************************************************************
     * RENOMEAR / EXCLUIR TRAJETO
     ************************************************************/
    function renameRoute(routeId) {
      const routes = getAllRoutes();
      const idx = routes.findIndex((r) => r.id === routeId);
      if (idx === -1) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      const currentName = routes[idx].name || "";
      const newName = prompt("Novo nome para este trajeto:", currentName);
      if (!newName) {
        return; // cancelado
      }

      routes[idx].name = newName;
      saveAllRoutes(routes);
      loadRoutesFromStorage();

      const routeSelect = document.getElementById("routeSelect");
      routeSelect.value = routeId;

      const updatedRoute = routes[idx];
      showRouteOnMap(updatedRoute);
      updateRouteInfo(updatedRoute);
      renderTrapList(updatedRoute);
    }

    function deleteRoute(routeId) {
      const routes = getAllRoutes();
      const route = routes.find((r) => r.id === routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      const ok = confirm(
        `Deseja realmente excluir o trajeto "${route.name}"?\nEssa a√ß√£o n√£o pode ser desfeita.`
      );
      if (!ok) return;

      const newRoutes = routes.filter((r) => r.id !== routeId);
      saveAllRoutes(newRoutes);
      loadRoutesFromStorage();

      clearMapLayers();
      updateRouteInfo(null);
      const trapList = document.getElementById("trapList");
      trapList.innerHTML = "Nenhum trajeto selecionado.";
      updateMonitorInfo("Monitoramento de iscas inativo.");

      const status = document.getElementById("status");
      status.textContent = "Trajeto exclu√≠do.";
    }

    /************************************************************
     * MONITORAMENTO DE ISCAS (GUIA ISCA POR ISCA)
     ************************************************************/
    function startMonitoringRoute(routeId) {
      if (!("geolocation" in navigator)) {
        alert("Seu navegador n√£o suporta Geolocaliza√ß√£o.");
        return;
      }

      const routes = getAllRoutes();
      const route = routes.find((r) => r.id === routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      if (!route.traps || route.traps.length === 0) {
        alert("Este trajeto n√£o possui pontos de isca registrados.");
        return;
      }

      if (isTracking) {
        alert("Pare a grava√ß√£o de trajeto antes de iniciar o monitoramento de iscas.");
        return;
      }

      monitorState.active = true;
      monitorState.routeId = routeId;
      monitorState.visited = [];
      monitorState.currentTrapId = null;
      monitorState.currentPosition = null;
      monitorLine.setLatLngs([]);

      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");
      btnMonitorRoute.textContent = "‚èπ Parar monitoramento";
      btnNextTrap.disabled = false;
      btnNextTrap.classList.remove("btn-disabled");

      updateMonitorInfo("Monitorando iscas‚Ä¶ aguardando posi√ß√£o GPS.");

      // Inicia monitoramento de posi√ß√£o
      monitorState.watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          monitorState.currentPosition = { lat: latitude, lng: longitude };

          // Atualiza marcador de posi√ß√£o atual no mapa
          if (currentMarker) {
            currentMarker.setLatLng([latitude, longitude]);
          } else {
            currentMarker = L.marker([latitude, longitude]).addTo(map);
          }

          // Se ainda n√£o temos isca alvo, escolhe a mais pr√≥xima
          const routesNow = getAllRoutes();
          const rNow = routesNow.find((r) => r.id === monitorState.routeId);
          if (!rNow || !rNow.traps || rNow.traps.length === 0) {
            updateMonitorInfo("Nenhuma isca encontrada neste trajeto.");
            return;
          }

          if (!monitorState.currentTrapId) {
            selectNearestTrap(rNow);
          } else {
            // Atualiza dist√¢ncia at√© a isca atual
            const trap = rNow.traps.find((t) => t.id === monitorState.currentTrapId);
            if (trap) {
              updateMonitorTargetUI(trap);
            }
          }
        },
        (err) => {
          console.error("Erro no monitoramento de iscas (GPS):", err);
          alert("N√£o foi poss√≠vel obter sua localiza√ß√£o para monitorar as iscas: " + err.message);
          stopMonitoringRoute();
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 20000,
        }
      );
    }

    function stopMonitoringRoute() {
      if (!monitorState.active) return;

      if (monitorState.watchId !== null) {
        navigator.geolocation.clearWatch(monitorState.watchId);
        monitorState.watchId = null;
      }

      monitorState.active = false;
      monitorState.routeId = null;
      monitorState.visited = [];
      monitorState.currentTrapId = null;
      monitorState.currentPosition = null;
      monitorLine.setLatLngs([]);

      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");
      btnMonitorRoute.textContent = "üì° Monitorar iscas";
      btnNextTrap.disabled = true;
      btnNextTrap.classList.add("btn-disabled");

      updateMonitorInfo("Monitoramento de iscas inativo.");
    }

    function updateMonitorInfo(text) {
      const monitorDiv = document.getElementById("monitorInfo");
      monitorDiv.textContent = text;
    }

    function selectNearestTrap(route) {
      const pos = monitorState.currentPosition;
      const traps = route.traps || [];
      if (traps.length === 0) {
        updateMonitorInfo("Nenhum ponto de isca registrado neste trajeto.");
        return;
      }

      // Filtra iscas ainda n√£o visitadas nesta sess√£o
      const remaining = traps.filter(
        (t) => !monitorState.visited.includes(t.id)
      );

      if (remaining.length === 0) {
        updateMonitorInfo("Todas as iscas deste trajeto j√° foram visitadas nesta sess√£o.");
        stopMonitoringRoute();
        return;
      }

      let chosen;
      if (!pos) {
        // Sem posi√ß√£o ainda: segue ordem cronol√≥gica (primeira n√£o visitada)
        chosen = remaining[0];
      } else {
        // Escolhe a mais pr√≥xima da posi√ß√£o atual
        let minDist = Infinity;
        remaining.forEach((t) => {
          const d = distanceInMeters(pos.lat, pos.lng, t.lat, t.lng);
          if (d < minDist) {
            minDist = d;
            chosen = t;
          }
        });
      }

      if (chosen) {
        monitorState.currentTrapId = chosen.id;
        updateMonitorTargetUI(chosen);
      }
    }

    function updateMonitorTargetUI(trap) {
      const pos = monitorState.currentPosition;
      if (!pos) {
        updateMonitorInfo("Monitorando iscas‚Ä¶ aguardando posi√ß√£o GPS.");
        return;
      }

      const dist = distanceInMeters(pos.lat, pos.lng, trap.lat, trap.lng);
      const dir = bearingToDirection(pos.lat, pos.lng, trap.lat, trap.lng);

      // Atualiza linha no mapa
      monitorLine.setLatLngs([
        [pos.lat, pos.lng],
        [trap.lat, trap.lng],
      ]);

      // Centraliza de forma confort√°vel
      const bounds = L.latLngBounds(
        [pos.lat, pos.lng],
        [trap.lat, trap.lng]
      );
      map.fitBounds(bounds, { padding: [30, 30] });

      updateMonitorInfo(
        `Pr√≥xima isca: coordenadas (${trap.lat.toFixed(
          5
        )}, ${trap.lng.toFixed(
          5
        )}) ‚Äì aprox. ${dist.toFixed(1)} m ‚Äì dire√ß√£o ${dir}.` +
          " Ao chegar, toque em 'Pr√≥xima isca' para seguir para a pr√≥xima."
      );
    }

    function goToNextTrap() {
      if (!monitorState.active) {
        alert("Inicie o monitoramento de iscas primeiro.");
        return;
      }
      const routes = getAllRoutes();
      const route = routes.find((r) => r.id === monitorState.routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        stopMonitoringRoute();
        return;
      }

      if (!monitorState.currentTrapId) {
        // ainda n√£o escolheu nenhuma, tenta escolher agora
        selectNearestTrap(route);
        return;
      }

      // Marca a atual como visitada
      if (!monitorState.visited.includes(monitorState.currentTrapId)) {
        monitorState.visited.push(monitorState.currentTrapId);
      }
      monitorState.currentTrapId = null;
      monitorLine.setLatLngs([]);

      // Escolhe a pr√≥xima
      selectNearestTrap(route);
    }

    /************************************************************
     * MODAL DE FOTO AMPLIADA
     ************************************************************/
    function setupPhotoModal() {
      const modal = document.getElementById("photoModal");
      if (!modal) return;

      modal.addEventListener("click", () => {
        modal.classList.remove("visible");
      });
    }

    function openPhotoModal(src) {
      const modal = document.getElementById("photoModal");
      const img = document.getElementById("photoModalImg");
      if (!modal || !img) return;

      img.src = src;
      modal.classList.add("visible");
    }

    window.openPhotoModal = openPhotoModal;

    /************************************************************
     * HELPERS
     ************************************************************/
    function formatDateTime(d) {
      if (!(d instanceof Date) || isNaN(d)) return "";
      const dia = String(d.getDate()).padStart(2, "0");
      const mes = String(d.getMonth() + 1).padStart(2, "0");
      const ano = d.getFullYear();
      const hora = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dia}/${mes}/${ano} ${hora}:${min}`;
    }

    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // Dist√¢ncia em metros (f√≥rmula de Haversine)
    function distanceInMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000; // raio da Terra em metros
      const toRad = (x) => (x * Math.PI) / 180;

      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Dire√ß√£o aproximada (N, NE, E, SE, S, SW, W, NW)
    function bearingToDirection(lat1, lon1, lat2, lon2) {
      const toRad = (x) => (x * Math.PI) / 180;
      const toDeg = (x) => (x * 180) / Math.PI;

      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x =
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) -
        Math.sin(toRad(lat1)) * Math.sin(toRad(lat2)) * Math.cos(dLon);
      let brng = toDeg(Math.atan2(y, x));
      brng = (brng + 360) % 360;

      const dirs = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
      const idx = Math.round(brng / 45) % 8;
      return dirs[idx];
    }

    // Registro do Service Worker para PWA
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./sw.js")
          .then((reg) => {
            console.log("Service Worker registrado com sucesso:", reg.scope);
          })
          .catch((err) => {
            console.warn("Falha ao registrar Service Worker:", err);
          });
      });
    }
  </script>
</body>
</html>
