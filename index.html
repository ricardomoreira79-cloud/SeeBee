<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Ninhos de Abelhas - Rastreador de Trajeto</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="theme-color" content="#145a32" />
  <link rel="manifest" href="manifest.webmanifest" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
  </script>

  <style>
    :root {
      --primary: #145a32;
      --primary-dark: #0b3d21;
      --accent: #f1c40f;
      --bg: #f4f6f7;
      --border-radius: 12px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #222;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    header h1 {
      margin: 0;
      font-size: 1.3rem;
    }

    header p {
      margin: 4px 0 0;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
    }

    main {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      flex: 1;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      padding: 10px 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.2s;
      white-space: nowrap;
    }

    button:active {
      transform: scale(0.97);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) inset;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-secondary {
      background: #e5e7e9;
      color: #333;
    }

    .btn-danger {
      background: #c0392b;
      color: white;
    }

    .btn-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-small {
      padding: 5px 10px;
      font-size: 0.8rem;
    }

    #status {
      font-size: 0.85rem;
      margin-top: 6px;
      color: #555;
    }

    label {
      font-size: 0.85rem;
      margin-right: 6px;
    }

    select {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #ccc;
      font-size: 0.85rem;
      max-width: 100%;
    }

    .route-header {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }

    .route-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    #map {
      width: 100%;
      height: 55vh;
      border-radius: var(--border-radius);
      overflow: hidden;
    }

    .info {
      font-size: 0.8rem;
      color: #555;
    }

    .info strong {
      color: #222;
    }

    .trap-list {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 6px;
      padding-left: 16px;
      font-size: 0.8rem;
    }

    .trap-item {
      margin-bottom: 8px;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #eaf2f8;
      color: #1b4f72;
      margin-left: 4px;
    }

    .photo-thumb {
      max-width: 100px;
      max-height: 80px;
      display: block;
      margin-top: 4px;
      border-radius: 8px;
      cursor: zoom-in;
    }

    footer {
      text-align: center;
      padding: 4px 8px;
      font-size: 0.7rem;
      color: #777;
    }

    .photo-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 10px;
    }

    .photo-modal.visible {
      display: flex;
    }

    .photo-modal img {
      max-width: 100%;
      max-height: 100%;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    }

    .photo-modal-hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #eee;
      font-size: 0.8rem;
      text-align: center;
      opacity: 0.8;
    }

    @media (min-width: 768px) {
      main {
        flex-direction: row;
      }

      #map {
        height: 70vh;
      }

      .left,
      .right {
        flex: 1;
      }

      .left {
        max-width: 380px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Ninhos de Abelhas ‚Äì Rastreador</h1>
      <p>Registre seus trajetos, marque ninhos com foto e consulte depois.</p>
    </div>
    <div class="header-right">
      <span id="cloudStatus">Conectado √† nuvem (Supabase)</span>
    </div>
  </header>

  <main>
    <section class="left">
      <div class="card">
        <div class="controls">
          <button id="btnStartStop" class="btn-primary">
            ‚ñ∂ Iniciar trajeto
          </button>

          <button id="btnMarkTrap" class="btn-secondary btn-disabled" disabled>
            üìç Marcar ponto de ninho
          </button>
        </div>

        <div id="status">
          Aguardando in√≠cio do trajeto‚Ä¶
        </div>
      </div>

      <div class="card" style="margin-top: 8px;">
        <div class="route-header" style="margin-bottom: 6px;">
          <div>
            <label for="routeSelect"><strong>Trajetos salvos:</strong></label>
            <select id="routeSelect">
              <option value="">Selecione um trajeto‚Ä¶</option>
            </select>
          </div>
        </div>

        <div class="route-actions">
          <button id="btnRenameRoute" class="btn-secondary btn-small">
            ‚úèÔ∏è Renomear trajeto
          </button>
          <button id="btnDeleteRoute" class="btn-secondary btn-small">
            üóëÔ∏è Excluir trajeto
          </button>
          <button id="btnMonitorRoute" class="btn-secondary btn-small">
            üì° Monitorar ninhos
          </button>
          <button id="btnNextTrap" class="btn-secondary btn-small btn-disabled" disabled>
            ‚û° Pr√≥ximo ninho
          </button>
        </div>

        <div class="info" id="routeInfo" style="margin-top: 8px;">
          Nenhum trajeto selecionado.
        </div>

        <div class="info" id="monitorInfo" style="margin-top: 6px;">
          Monitoramento de ninhos inativo.
        </div>

        <div class="trap-list" id="trapList">
        </div>
      </div>
    </section>

    <section class="right">
      <div class="card" style="padding: 0;">
        <div id="map"></div>
      </div>
    </section>
  </main>

  <footer>
    Dados de trajetos salvos na nuvem (Supabase). Fotos dos ninhos ficam apenas neste aparelho.
  </footer>

  <input
    type="file"
    id="photoInput"
    accept="image/*"
    capture="environment"
    style="display: none;"
  />

  <div id="photoModal" class="photo-modal">
    <img id="photoModalImg" src="" alt="Foto ampliada do ninho" />
    <div class="photo-modal-hint">Toque em qualquer lugar para fechar</div>
  </div>

  <!-- Script principal com Supabase -->
  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    // üîß PREENCHA COM OS DADOS DO SEU PROJETO
    const SUPABASE_URL = "https://sgrtyotwnlwpwfecnoze.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNncnR5b3R3bmx3cHdmZWNub3plIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NjgxMjcsImV4cCI6MjA4MzM0NDEyN30.QZvTN3mHUwqBwvXeL6q89qNW_4s1Cvopa40nt4TFa9w";

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /************************************************************
     * ESTADO GLOBAL
     ************************************************************/
    let map;
    let pathPolyline;
    let currentMarker;
    let trapsLayerGroup;
    let monitorLine;

    let isTracking = false;
    let watchId = null;
    let currentRoute = null;

    const monitorState = {
      active: false,
      routeId: null,
      visited: [],
      currentTrapId: null,
      watchId: null,
      currentPosition: null,
    };

    // cache em mem√≥ria das rotas carregadas da nuvem
    window.cachedRoutes = [];

    /************************************************************
     * INICIALIZA√á√ÉO
     ************************************************************/
    document.addEventListener("DOMContentLoaded", () => {
      initMap();
      bindUI();
      setupPhotoModal();
      loadRoutesFromSupabase();
    });

    function initMap() {
      map = L.map("map").setView([-15.0, -56.0], 5);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "¬© OpenStreetMap contributors",
      }).addTo(map);

      pathPolyline = L.polyline([], { weight: 4 }).addTo(map);
      trapsLayerGroup = L.layerGroup().addTo(map);
      monitorLine = L.polyline([], { weight: 2, dashArray: "5,5" }).addTo(map);

      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            map.setView([latitude, longitude], 16);
            currentMarker = L.marker([latitude, longitude]).addTo(map);
          },
          (err) => {
            console.log("N√£o foi poss√≠vel centralizar pela localiza√ß√£o inicial:", err);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 5000,
            timeout: 15000,
          }
        );
      }
    }

    function bindUI() {
      const btnStartStop = document.getElementById("btnStartStop");
      const btnMarkTrap = document.getElementById("btnMarkTrap");
      const routeSelect = document.getElementById("routeSelect");
      const photoInput = document.getElementById("photoInput");
      const btnRenameRoute = document.getElementById("btnRenameRoute");
      const btnDeleteRoute = document.getElementById("btnDeleteRoute");
      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");

      btnStartStop.addEventListener("click", async () => {
        if (!isTracking) {
          startTracking();
        } else {
          await stopTracking();
        }
      });

      btnMarkTrap.addEventListener("click", () => {
        if (!isTracking || !currentRoute) {
          alert("Inicie um trajeto antes de marcar pontos de ninho.");
          return;
        }
        handleMarkTrap();
      });

      routeSelect.addEventListener("change", () => {
        const id = routeSelect.value;
        if (!id) {
          clearMapLayers();
          updateRouteInfo(null);
          updateMonitorInfo("Monitoramento de ninhos inativo.");
          document.getElementById("trapList").innerHTML = "";
          return;
        }
        const route = findRouteById(id);
        if (route) {
          showRouteOnMap(route);
          updateRouteInfo(route);
          renderTrapList(route);
          if (monitorState.active && monitorState.routeId !== id) {
            stopMonitoringRoute();
          }
        }
      });

      btnRenameRoute.addEventListener("click", async () => {
        const id = routeSelect.value;
        if (!id) {
          alert("Selecione um trajeto para renomear.");
          return;
        }
        if (monitorState.active) {
          stopMonitoringRoute();
        }
        await renameRoute(id);
      });

      btnDeleteRoute.addEventListener("click", async () => {
        const id = routeSelect.value;
        if (!id) {
          alert("Selecione um trajeto para excluir.");
          return;
        }
        if (monitorState.active && monitorState.routeId === id) {
          stopMonitoringRoute();
        }
        await deleteRoute(id);
      });

      btnMonitorRoute.addEventListener("click", () => {
        const id = routeSelect.value;
        if (!id) {
          alert("Selecione um trajeto para monitorar.");
          return;
        }

        if (!monitorState.active) {
          startMonitoringRoute(id);
        } else {
          stopMonitoringRoute();
        }
      });

      btnNextTrap.addEventListener("click", () => {
        goToNextTrap();
      });

      photoInput.addEventListener("change", handlePhotoSelected);
    }

    /************************************************************
     * SUPABASE ‚Äì ROTAS
     ************************************************************/
    async function getAllRoutes() {
      const cloudStatus = document.getElementById("cloudStatus");
      const { data, error } = await supabase
        .from("routes")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error("Erro ao carregar rotas do Supabase:", error);
        cloudStatus.textContent = "Erro ao conectar √† nuvem";
        cloudStatus.style.color = "#ffdddd";
        return [];
      }

      cloudStatus.textContent = "Conectado √† nuvem (Supabase)";
      cloudStatus.style.color = "#e8f5e9";

      return (data || []).map((row) => ({
        id: row.id,
        name: row.name,
        createdAt: row.created_at,
        path: row.path || [],
        traps: row.traps || [],
      }));
    }

    async function loadRoutesFromSupabase() {
      const routeSelect = document.getElementById("routeSelect");
      const routes = await getAllRoutes();

      window.cachedRoutes = routes;

      routeSelect.innerHTML = '<option value="">Selecione um trajeto‚Ä¶</option>';

      routes.forEach((r) => {
        const inicioStr =
          r.path && r.path.length > 0
            ? formatDateTime(new Date(r.path[0].timestamp))
            : formatDateTime(new Date(r.createdAt));
        const totalNinhos = r.traps ? r.traps.length : 0;

        const opt = document.createElement("option");
        opt.value = r.id;
        opt.textContent = `${r.name} ‚Äì ${totalNinhos} ninho(s) ‚Äì ${inicioStr}`;
        routeSelect.appendChild(opt);
      });
    }

    async function saveRouteToSupabase(route) {
      const { error } = await supabase.from("routes").insert({
        id: route.id,
        name: route.name,
        created_at: route.createdAt,
        path: route.path,
        traps: route.traps,
      });

      if (error) {
        console.error("Erro ao salvar rota no Supabase:", error);
        alert("Erro ao salvar trajeto na nuvem. Ele ficar√° apenas neste aparelho.");
      }
    }

    async function updateRouteTrapsInSupabase(routeId, traps) {
      const { error } = await supabase
        .from("routes")
        .update({ traps })
        .eq("id", routeId);

      if (error) {
        console.error("Erro ao atualizar ninhos no Supabase:", error);
      }
    }

    async function updateRouteNameInSupabase(routeId, newName) {
      const { error } = await supabase
        .from("routes")
        .update({ name: newName })
        .eq("id", routeId);

      if (error) {
        console.error("Erro ao renomear rota no Supabase:", error);
        alert("Erro ao renomear trajeto na nuvem.");
        return false;
      }
      return true;
    }

    async function deleteRouteFromSupabase(routeId) {
      const { error } = await supabase
        .from("routes")
        .delete()
        .eq("id", routeId);

      if (error) {
        console.error("Erro ao excluir rota no Supabase:", error);
        alert("Erro ao excluir trajeto na nuvem.");
        return false;
      }
      return true;
    }

    function findRouteById(id) {
      const routes = window.cachedRoutes || [];
      return routes.find((r) => r.id === id) || null;
    }

    /************************************************************
     * CONTROLE DO TRAJETO
     ************************************************************/
    function startTracking() {
      if (!("geolocation" in navigator)) {
        alert("Seu navegador n√£o suporta Geolocaliza√ß√£o.");
        return;
      }

      if (monitorState.active) {
        alert("Pare o monitoramento de ninhos antes de iniciar um novo trajeto.");
        return;
      }

      const name = prompt("Nome para este trajeto (ex: Matas do S√≠tio A):", "");
      if (!name) {
        alert("Trajeto n√£o iniciado (nome √© obrigat√≥rio).");
        return;
      }

      isTracking = true;
      currentRoute = {
        id: "route_" + Date.now(),
        name: name,
        createdAt: new Date().toISOString(),
        path: [],
        traps: [],
      };

      pathPolyline.setLatLngs([]);
      trapsLayerGroup.clearLayers();
      monitorLine.setLatLngs([]);
      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }

      document.getElementById("status").textContent =
        "Gravando trajeto‚Ä¶ caminhando com GPS ligado.";
      toggleTrackingButtons(true);

      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          const point = {
            lat: latitude,
            lng: longitude,
            timestamp: new Date().toISOString(),
          };
          currentRoute.path.push(point);

          pathPolyline.addLatLng([latitude, longitude]);

          if (currentMarker) {
            currentMarker.setLatLng([latitude, longitude]);
          } else {
            currentMarker = L.marker([latitude, longitude]).addTo(map);
          }

          map.setView([latitude, longitude], 16);
        },
        (err) => {
          console.error("Erro no watchPosition:", err);
          alert("N√£o foi poss√≠vel obter sua localiza√ß√£o: " + err.message);
          stopTracking();
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 20000,
        }
      );
    }

    async function stopTracking() {
      if (!isTracking) return;

      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      isTracking = false;
      toggleTrackingButtons(false);

      const status = document.getElementById("status");
      status.textContent = "Trajeto encerrado.";

      if (currentRoute && currentRoute.path.length > 0) {
        await saveRouteToSupabase(currentRoute);
        await loadRoutesFromSupabase();

        const routeSelect = document.getElementById("routeSelect");
        routeSelect.value = currentRoute.id;

        const route = findRouteById(currentRoute.id);
        if (route) {
          showRouteOnMap(route);
          updateRouteInfo(route);
          renderTrapList(route);
        }

        alert("Trajeto salvo com sucesso na nuvem!");
      } else {
        alert("Nenhum ponto foi registrado. Trajeto n√£o ser√° salvo.");
      }

      currentRoute = null;
    }

    function toggleTrackingButtons(tracking) {
      const btnStartStop = document.getElementById("btnStartStop");
      const btnMarkTrap = document.getElementById("btnMarkTrap");

      if (tracking) {
        btnStartStop.textContent = "‚ñ† Encerrar trajeto";
        btnStartStop.classList.remove("btn-primary");
        btnStartStop.classList.add("btn-danger");

        btnMarkTrap.disabled = false;
        btnMarkTrap.classList.remove("btn-disabled");
      } else {
        btnStartStop.textContent = "‚ñ∂ Iniciar trajeto";
        btnStartStop.classList.remove("btn-danger");
        btnStartStop.classList.add("btn-primary");

        btnMarkTrap.disabled = true;
        btnMarkTrap.classList.add("btn-disabled");
      }
    }

    /************************************************************
     * NINHOS (TRAPS)
     ************************************************************/
    let pendingTrapPosition = null;

    function handleMarkTrap() {
      if (!currentRoute) return;

      const lastPoint = currentRoute.path[currentRoute.path.length - 1];

      const finishMark = (lat, lng) => {
        pendingTrapPosition = { lat, lng, timestamp: new Date().toISOString() };
        document.getElementById("photoInput").click();
      };

      if (lastPoint) {
        finishMark(lastPoint.lat, lastPoint.lng);
      } else {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            finishMark(latitude, longitude);
          },
          (err) => {
            alert(
              "N√£o foi poss√≠vel obter a localiza√ß√£o para marcar o ponto: " +
                err.message
            );
          },
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 15000,
          }
        );
      }
    }

    function handlePhotoSelected(event) {
      const file = event.target.files[0];
      if (!pendingTrapPosition) {
        event.target.value = "";
        return;
      }

      const note =
        prompt("Alguma observa√ß√£o sobre este ninho? (opcional)", "") || "";

      if (!file) {
        registerTrap(
          pendingTrapPosition.lat,
          pendingTrapPosition.lng,
          null,
          note
        );
        pendingTrapPosition = null;
        return;
      }

      const reader = new FileReader();
      reader.onload = function (e) {
        const photoDataUrl = e.target.result;
        registerTrap(
          pendingTrapPosition.lat,
          pendingTrapPosition.lng,
          photoDataUrl,
          note
        );
        pendingTrapPosition = null;
        event.target.value = "";
      };
      reader.readAsDataURL(file);
    }

    function registerTrap(lat, lng, photoDataUrl, note) {
      if (!currentRoute && !monitorState.routeId) {
        return;
      }

      if (currentRoute) {
        const trap = {
          id: "trap_" + Date.now(),
          lat,
          lng,
          timestamp: new Date().toISOString(),
          note,
          photo: photoDataUrl,
        };

        currentRoute.traps.push(trap);

        const popupHtml = createTrapPopupHtml(trap);
        const marker = L.marker([lat, lng]).addTo(trapsLayerGroup);
        marker.bindPopup(popupHtml);

        alert("Ponto de ninho registrado!");
        return;
      }

      // caso futuro: adicionar ninho em trajeto j√° salvo, via monitoramento
    }

    function createTrapPopupHtml(trap) {
      const dt = formatDateTime(new Date(trap.timestamp));
      let html = `<div><strong>Ninho</strong><br/><small>${dt}</small>`;
      if (trap.note) {
        html += `<br/><em>${escapeHtml(trap.note)}</em>`;
      }
      if (trap.photo) {
        html += `<br/><img src="${trap.photo}" alt="Foto do ninho" style="max-width:120px;max-height:90px;margin-top:4px;border-radius:6px;" />`;
      }
      html += `</div>`;
      return html;
    }

    /************************************************************
     * EXIBI√á√ÉO NO MAPA / LISTA
     ************************************************************/
    function clearMapLayers() {
      pathPolyline.setLatLngs([]);
      trapsLayerGroup.clearLayers();
      monitorLine.setLatLngs([]);
      if (currentMarker) {
        map.removeLayer(currentMarker);
        currentMarker = null;
      }
    }

    function showRouteOnMap(route) {
      clearMapLayers();

      if (!route.path || route.path.length === 0) return;

      const latlngs = route.path.map((p) => [p.lat, p.lng]);
      pathPolyline.setLatLngs(latlngs);

      const last = latlngs[latlngs.length - 1];
      currentMarker = L.marker(last).addTo(map);

      if (route.traps && route.traps.length > 0) {
        route.traps.forEach((trap) => {
          const marker = L.marker([trap.lat, trap.lng]).addTo(trapsLayerGroup);
          marker.bindPopup(createTrapPopupHtml(trap));
        });
      }

      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds, { padding: [20, 20] });
    }

    function updateRouteInfo(route) {
      const infoDiv = document.getElementById("routeInfo");
      if (!route) {
        infoDiv.textContent = "Nenhum trajeto selecionado.";
        document.getElementById("trapList").innerHTML = "";
        return;
      }

      const totalNinhos = route.traps ? route.traps.length : 0;

      let inicioStr = "-";
      let fimStr = "-";

      if (route.path && route.path.length > 0) {
        const inicio = new Date(route.path[0].timestamp);
        const fim = new Date(route.path[route.path.length - 1].timestamp);
        inicioStr = formatDateTime(inicio);
        fimStr = formatDateTime(fim);
      }

      infoDiv.innerHTML = `
        <div><strong>${escapeHtml(route.name)}</strong></div>
        <div>In√≠cio do trajeto: <strong>${inicioStr}</strong></div>
        <div>Fim do trajeto: <strong>${fimStr}</strong></div>
        <div>N¬∫ de ninhos marcados: <strong>${totalNinhos}</strong></div>
      `;
    }

    function renderTrapList(route) {
      const listDiv = document.getElementById("trapList");
      listDiv.innerHTML = "";
      if (!route.traps || route.traps.length === 0) {
        listDiv.textContent = "Nenhum ponto de ninho registrado neste trajeto.";
        return;
      }

      route.traps.forEach((trap, idx) => {
        const dt = formatDateTime(new Date(trap.timestamp));
        const item = document.createElement("div");
        item.className = "trap-item";
        item.innerHTML = `
          <strong>Ninho ${idx + 1}</strong>
          <span class="badge">${trap.lat.toFixed(5)}, ${trap.lng.toFixed(
          5
        )}</span><br/>
          <small>${dt}</small><br/>
          ${
            trap.note
              ? `<em>${escapeHtml(trap.note)}</em><br/>`
              : ""
          }
        `;
        if (trap.photo) {
          const img = document.createElement("img");
          img.src = trap.photo;
          img.alt = "Foto do ninho";
          img.className = "photo-thumb";
          img.addEventListener("click", () => {
            openPhotoModal(trap.photo);
          });
          item.appendChild(img);
        }
        listDiv.appendChild(item);
      });
    }

    /************************************************************
     * RENOMEAR / EXCLUIR
     ************************************************************/
    async function renameRoute(routeId) {
      const route = findRouteById(routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      const currentName = route.name || "";
      const newName = prompt("Novo nome para este trajeto:", currentName);
      if (!newName) return;

      const ok = await updateRouteNameInSupabase(routeId, newName);
      if (!ok) return;

      await loadRoutesFromSupabase();

      const updated = findRouteById(routeId);
      const routeSelect = document.getElementById("routeSelect");
      routeSelect.value = routeId;

      if (updated) {
        showRouteOnMap(updated);
        updateRouteInfo(updated);
        renderTrapList(updated);
      }
    }

    async function deleteRoute(routeId) {
      const route = findRouteById(routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      const okConfirm = confirm(
        `Deseja realmente excluir o trajeto "${route.name}"?\nEssa a√ß√£o n√£o pode ser desfeita.`
      );
      if (!okConfirm) return;

      const ok = await deleteRouteFromSupabase(routeId);
      if (!ok) return;

      await loadRoutesFromSupabase();

      clearMapLayers();
      updateRouteInfo(null);
      document.getElementById("trapList").innerHTML =
        "Nenhum trajeto selecionado.";
      updateMonitorInfo("Monitoramento de ninhos inativo.");
      document.getElementById("status").textContent = "Trajeto exclu√≠do.";
    }

    /************************************************************
     * MONITORAMENTO DE NINHOS
     ************************************************************/
    function startMonitoringRoute(routeId) {
      if (!("geolocation" in navigator)) {
        alert("Seu navegador n√£o suporta Geolocaliza√ß√£o.");
        return;
      }

      const route = findRouteById(routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        return;
      }

      if (!route.traps || route.traps.length === 0) {
        alert("Este trajeto n√£o possui ninhos registrados.");
        return;
      }

      if (isTracking) {
        alert("Pare a grava√ß√£o de trajeto antes de iniciar o monitoramento de ninhos.");
        return;
      }

      monitorState.active = true;
      monitorState.routeId = routeId;
      monitorState.visited = [];
      monitorState.currentTrapId = null;
      monitorState.currentPosition = null;
      monitorLine.setLatLngs([]);

      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");
      btnMonitorRoute.textContent = "‚èπ Parar monitoramento";
      btnNextTrap.disabled = false;
      btnNextTrap.classList.remove("btn-disabled");

      updateMonitorInfo("Monitorando ninhos‚Ä¶ aguardando posi√ß√£o GPS.");

      monitorState.watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          monitorState.currentPosition = { lat: latitude, lng: longitude };

          if (currentMarker) {
            currentMarker.setLatLng([latitude, longitude]);
          } else {
            currentMarker = L.marker([latitude, longitude]).addTo(map);
          }

          const rNow = findRouteById(monitorState.routeId);
          if (!rNow || !rNow.traps || rNow.traps.length === 0) {
            updateMonitorInfo("Nenhum ninho encontrado neste trajeto.");
            return;
          }

          if (!monitorState.currentTrapId) {
            selectNearestTrap(rNow);
          } else {
            const trap = rNow.traps.find((t) => t.id === monitorState.currentTrapId);
            if (trap) {
              updateMonitorTargetUI(trap);
            }
          }
        },
        (err) => {
          console.error("Erro no monitoramento de ninhos (GPS):", err);
          alert("N√£o foi poss√≠vel obter sua localiza√ß√£o para monitorar os ninhos: " + err.message);
          stopMonitoringRoute();
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 20000,
        }
      );
    }

    function stopMonitoringRoute() {
      if (!monitorState.active) return;

      if (monitorState.watchId !== null) {
        navigator.geolocation.clearWatch(monitorState.watchId);
        monitorState.watchId = null;
      }

      monitorState.active = false;
      monitorState.routeId = null;
      monitorState.visited = [];
      monitorState.currentTrapId = null;
      monitorState.currentPosition = null;
      monitorLine.setLatLngs([]);

      const btnMonitorRoute = document.getElementById("btnMonitorRoute");
      const btnNextTrap = document.getElementById("btnNextTrap");
      btnMonitorRoute.textContent = "üì° Monitorar ninhos";
      btnNextTrap.disabled = true;
      btnNextTrap.classList.add("btn-disabled");

      updateMonitorInfo("Monitoramento de ninhos inativo.");
    }

    function updateMonitorInfo(text) {
      const monitorDiv = document.getElementById("monitorInfo");
      monitorDiv.textContent = text;
    }

    function selectNearestTrap(route) {
      const pos = monitorState.currentPosition;
      const traps = route.traps || [];
      if (traps.length === 0) {
        updateMonitorInfo("Nenhum ninho registrado neste trajeto.");
        return;
      }

      const remaining = traps.filter(
        (t) => !monitorState.visited.includes(t.id)
      );

      if (remaining.length === 0) {
        updateMonitorInfo("Todos os ninhos deste trajeto j√° foram visitados nesta sess√£o.");
        stopMonitoringRoute();
        return;
      }

      let chosen;
      if (!pos) {
        chosen = remaining[0];
      } else {
        let minDist = Infinity;
        remaining.forEach((t) => {
          const d = distanceInMeters(pos.lat, pos.lng, t.lat, t.lng);
          if (d < minDist) {
            minDist = d;
            chosen = t;
          }
        });
      }

      if (chosen) {
        monitorState.currentTrapId = chosen.id;
        updateMonitorTargetUI(chosen);
      }
    }

    function updateMonitorTargetUI(trap) {
      const pos = monitorState.currentPosition;
      if (!pos) {
        updateMonitorInfo("Monitorando ninhos‚Ä¶ aguardando posi√ß√£o GPS.");
        return;
      }

      const dist = distanceInMeters(pos.lat, pos.lng, trap.lat, trap.lng);
      const dir = bearingToDirection(pos.lat, pos.lng, trap.lat, trap.lng);

      monitorLine.setLatLngs([
        [pos.lat, pos.lng],
        [trap.lat, trap.lng],
      ]);

      const bounds = L.latLngBounds(
        [pos.lat, pos.lng],
        [trap.lat, trap.lng]
      );
      map.fitBounds(bounds, { padding: [30, 30] });

      updateMonitorInfo(
        `Pr√≥ximo ninho: coordenadas (${trap.lat.toFixed(
          5
        )}, ${trap.lng.toFixed(
          5
        )}) ‚Äì aprox. ${dist.toFixed(1)} m ‚Äì dire√ß√£o ${dir}.` +
          " Ao chegar, toque em 'Pr√≥ximo ninho' para seguir para o pr√≥ximo."
      );
    }

    function goToNextTrap() {
      if (!monitorState.active) {
        alert("Inicie o monitoramento de ninhos primeiro.");
        return;
      }
      const route = findRouteById(monitorState.routeId);
      if (!route) {
        alert("Trajeto n√£o encontrado.");
        stopMonitoringRoute();
        return;
      }

      if (!monitorState.currentTrapId) {
        selectNearestTrap(route);
        return;
      }

      if (!monitorState.visited.includes(monitorState.currentTrapId)) {
        monitorState.visited.push(monitorState.currentTrapId);
      }
      monitorState.currentTrapId = null;
      monitorLine.setLatLngs([]);

      selectNearestTrap(route);
    }

    /************************************************************
     * MODAL DE FOTO
     ************************************************************/
    function setupPhotoModal() {
      const modal = document.getElementById("photoModal");
      if (!modal) return;

      modal.addEventListener("click", () => {
        modal.classList.remove("visible");
      });
    }

    function openPhotoModal(src) {
      const modal = document.getElementById("photoModal");
      const img = document.getElementById("photoModalImg");
      if (!modal || !img) return;

      img.src = src;
      modal.classList.add("visible");
    }

    window.openPhotoModal = openPhotoModal;

    /************************************************************
     * HELPERS
     ************************************************************/
    function formatDateTime(d) {
      if (!(d instanceof Date) || isNaN(d)) return "";
      const dia = String(d.getDate()).padStart(2, "0");
      const mes = String(d.getMonth() + 1).padStart(2, "0");
      const ano = d.getFullYear();
      const hora = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dia}/${mes}/${ano} ${hora}:${min}`;
    }

    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function distanceInMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (x) => (x * Math.PI) / 180;

      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function bearingToDirection(lat1, lon1, lat2, lon2) {
      const toRad = (x) => (x * Math.PI) / 180;
      const toDeg = (x) => (x * 180) / Math.PI;

      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x =
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) -
        Math.sin(toRad(lat1)) * Math.sin(toRad(lat2)) * Math.cos(dLon);
      let brng = toDeg(Math.atan2(y, x));
      brng = (brng + 360) % 360;

      const dirs = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
      const idx = Math.round(brng / 45) % 8;
      return dirs[idx];
    }

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./sw.js")
          .then((reg) => {
            console.log("Service Worker registrado com sucesso:", reg.scope);
          })
          .catch((err) => {
            console.warn("Falha ao registrar Service Worker:", err);
          });
      });
    }
  </script>
</body>
</html>

